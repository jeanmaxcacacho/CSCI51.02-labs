\documentclass{article}

\usepackage{minted}
\usepackage{forest}

\pagenumbering{gobble}

\begin{document}

{\Large \textbf{Reference C++ Code A}}
\begin{minted}{c}
    if (fork() == 0) {
        // do stuff
    } else if (fork() == 0) {
        // do more stuff..
    } else if (fork() == 0) {
        // do more "stuff"..
    } else if (fork() == 0) {
        // noooo
    }
\end{minted}

{\Large \textbf{Reference C++ Code B}}
\begin{minted}{c}
    if (fork() == 0) {
        if (fork() == 0) {
            if (fork() == 0) {
                // if ...
                // aaaahhhh
            }
        }
    }
\end{minted}

{\Large \textbf{Reference C++ Code C}}
\begin{minted}{cpp}
    int main(int argc, char* argv[]) {
        // just use execv to run ANY program
        if (execv("/usr/bin/gedit", argv) == -1) {
            // error
            cout << "Error. Booooo!" << endl;
        }
        cout << "Will this line still be printed?" << endl;
    }
\end{minted}

These code snippets were obtained from the Lab 6 assignment page.

\vfill
\newpage

\begin{enumerate}
    {\large \item What should be the resulting process \emph{FAMILY TREES} from these two (Code A and Code B) code snippets? Illustrate.}
    
    In reference code A all \texttt{fork()} calls performed at the same "hierarchy level" in the if-else tree. The entry point starts at \texttt{if (fork() == 0)},
    which produces the first child process. However, should this \texttt{fork()} fail, the succeeding \texttt{fork()} calls in the following \texttt{else if (fork() == 0)}
    statement produces a child process accordingly. Once a \texttt{fork()} successfully produces a child, the program enters the respective instruction block and stops forking.
    \textbf{The resulting process family tree from code A looks like:}
    \vspace{1em}

    \begin{forest}
        [Parent
            [Possible Child 1]
            [Possible Child 2]
            [Possible Child 3]
            [Possible Child 4]
        ]
    \end{forest}

    \emph{In this diagram, Possible Child $n$ for $n \geq 2$, only gets instantiated if the first $n - 1$ fork(s) fail.}

    In reference code B \texttt{fork()} calls are performed sequentially, with further calls only being called if the previous one succeeds. If the first \texttt{fork()}
    succeeds, then the second one is called, then if this succeeds the third one is called; so on and so forth. At the first \texttt{fork()} the parent produces a child,
    in the second one both parent and child produce a child, at the third call the parent, child, and the \emph{grandchild} all produce a child---effectively at each call
    the amount of total processes \emph{doubles}, demonstrating exponential growth. \textbf{The resulting process family tree from code B, can be illustrated
    per stage (up to the third fork):}
    \vspace{2em}

    \begin{center}
        {\large \textbf{1st Fork}}

        \begin{forest}
            [Parent
                [Child 1*]
            ]
        \end{forest}
    \end{center}
    \vspace{5em}

    \begin{center}
        {\large \textbf{2nd Fork}}

        \begin{forest}
            [Parent
                [Child 2**]
                [Child 1*
                    [Child 3**]]
            ]
        \end{forest}
    \end{center}
    \vfill
    \newpage

    \begin{center}
        {\large \textbf{3rd Fork}}

        \begin{forest}
            [Parent
                [Child 4***]
                [Child 2**
                    [Child 5***]]
                [Child 1*
                    [Child 3**
                        [Child 7***]]
                    [Child 6***]]
            ]
        \end{forest}
    \end{center}

    \emph{In this diagram each * denotes the $n$th fork at which the child was instantiated, where $n$
    represents the amount of asterisks trailing a child label.}

    Effectively at the third fork there will be a total of \textbf{8} processes, since at each fork
    in this structure the amount of processes double, we can express this as $2^n$ where $n$ is the
    amount of times the program calls \texttt{fork()}.


    {\large \item Will the last line in the sample code below (Code C) still be printed? How about when using \texttt{execl()}? Why or why not? Explain.}

    What Code C effectively does is to replace the current process with the gedit program from the user's \emph{programs} (/usr/bin/\ldots{} serves that
    purpose) directory. Should the \texttt{exec()} call succeed then the current process is \emph{replaced} with the program located within the specified
    path---if the call fails then the statement resolves to the value $-1$.

    Assuming that gedit is properly installed within the machine, or that there is a program to be executed in whatever path is passed into \texttt{execv()},
    then the program will never execute the instructions: \texttt{cout << "will this line still be printed?" << endl}, since the process containing those
    instructions would have already been replaced with what was passed into \texttt{execv()}.

    On the otherhand if the path passed into \texttt{execv()} does not exist, the current process does not get replaced and instead continues executing instructions
    stored within the current \texttt{*.cpp} file. In this case there will be two outputs to the terminal \texttt{Error. Booooo!} and \texttt{Will this line still be
    printed?}---since the process was not replaced by the call.

    The use of \texttt{execl()} will not make any major changes to the logic of whether or not the last line will be printed to the terminal or not, the only thing
    that changes is how the path is passed into the \texttt{exec()} function. Whereas in \texttt{execv()} we passed the file path with an array of arguments, \texttt{
    execl()} requires that the file path is passed followed by each argument as separate parameters. \textbf{The logic of whether or not the process gets replaced still is
    the same assuming that \texttt{execl()} is used properly, the only way it differs is in syntax.}

\end{enumerate}

\end{document}